using System.Collections.ObjectModel;
using System.IO.MemoryMappedFiles;
using System.Text;
using Accelerator.Commercetools.Importer.Extensions;
using Accelerator.Commercetools.Importer.Shared.Channels;
using Accelerator.Commercetools.Importer.Shared.Interfaces;
using Accelerator.Shared.Infrastructure;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace Accelerator.Commercetools.Importer.Shared.Services;

public readonly struct FileData(FileInfo fileInfo, string fileText, string separator)
{
    public FileInfo FileInfo { get; } = fileInfo;
    public string TextFile { get; } = fileText;
    public string Separator { get; } = separator;
}

public class FileConsumer<T> : IFileConsumer<T> 
    where T : class, new()
{
    private ReadOnlyCollection<string> _fileHeaders = new(new List<string>());
    private readonly FileProcessingChannel<FileData> _channelFileBuffer;
    private readonly DataBaseProcessingChannel<T> _dataBaseProcessingChannel;
    private readonly ILogger<FileConsumer<T>> _logger;
    private readonly IOptions<AcceleratorConfiguration> _fileConfiguration;

    private static string FetchSeparatorFromExtension(string pathExtension) => pathExtension switch
    {
        _ when pathExtension.EndsWith("csv") => ",",
        _ when pathExtension.EndsWith("txt") => "\t",
        _ when string.IsNullOrWhiteSpace(pathExtension) => throw new ArgumentNullException(),
        _ => throw new ArgumentOutOfRangeException(nameof(pathExtension), pathExtension, null)
    };


    public FileConsumer(ILogger<FileConsumer<T>> logger,
        IOptions<AcceleratorConfiguration> fileConfiguration,
        FileProcessingChannel<FileData> channelFileBuffer,
        DataBaseProcessingChannel<T> dataBaseProcessingChannel)
    {
        _logger = logger;
        _fileConfiguration = fileConfiguration;
        _channelFileBuffer = channelFileBuffer;
        _dataBaseProcessingChannel = dataBaseProcessingChannel;
    }

    public async ValueTask ReadAsync()
    {
        var textFiles =
            Directory.EnumerateFiles(_fileConfiguration.Value.SourceDirectory,
                    "*.*", 
                    SearchOption.AllDirectories)
                .Where(i => i.Contains(typeof(T).Name.TrimAutoGeneratedName()));
        
        foreach (var textFile in textFiles)
        {
            ValidateFile(textFile);
            _logger.LogInformation("Reading {TextFile}", textFile);
            
            var fileInfo = new FileInfo(textFile);
            var fileData = new FileData(fileInfo, textFile,FetchSeparatorFromExtension(Path.GetExtension(textFile)));

            await _channelFileBuffer.ProcessingChannel.Writer.WriteAsync(fileData);
        }
        _channelFileBuffer.ProcessingChannel.Writer.Complete();
    }
    
    public IEnumerable<Task> StartFileConsumers()
    {
        var maxParallelism = Math.Min(Environment.ProcessorCount - 2, 6);

        return Enumerable.Range(0, maxParallelism)
            .Select(_ => Task.Run(ProcessDataFromMemoryMappedFile))
            .ToList();
    }
    
    private async Task ProcessDataFromMemoryMappedFile()
    {
        await foreach (var fileData in _channelFileBuffer.ProcessingChannel.Reader.ReadAllAsync())
        {
            await ProcessMemoryMappedFile(fileData);
        }
    }

    private async Task ProcessMemoryMappedFile(FileData fileData)
    {
        var buffer = new List<string[]>();
        var index = 0;
        var byteBuffer = new byte[8192];
        using var mmf = MemoryMappedFile.CreateFromFile(fileData.TextFile, FileMode.Open, null, fileData.FileInfo.Length, MemoryMappedFileAccess.Read);
        using var accessor = mmf.CreateViewAccessor(0, fileData.FileInfo.Length, MemoryMappedFileAccess.Read);
        for (long i = 0; i < fileData.FileInfo.Length; i++)
        {
            accessor.Read(i, out byte b);

            if (b == 0xA)
            {
                var length = (int)(i - index);
                if (length > byteBuffer.Length)
                {
                    byteBuffer = new byte[length];
                }
                
                var bytesRead = accessor.ReadArray(index, byteBuffer, 0, (int)(i - index));
                var line = Encoding.UTF8.GetString(byteBuffer, 0, bytesRead);
                
                index = (int)(i + 1);
                if (_fileHeaders.Count == 0)
                {
                    _fileHeaders = line.Split(fileData.Separator).Select(s => s.ToLowerInvariant()
                            .Replace("-", string.Empty)
                            .Replace("_", string.Empty)
                            .Replace(" ", string.Empty))
                        .ToList()
                        .AsReadOnly();
                    continue;
                }

                var lineSplit = line.Split(fileData.Separator);
                ValidateRow(lineSplit, buffer.Count);
                buffer.Add(lineSplit);

                if (buffer.Count >= 100)
                {
                    await ProcessBatch(buffer);
                    buffer.Clear();
                }
            }
        }
    }
    
    private async Task ProcessBatch(List<string[]> lines)
    {
        var tasks = lines.Select(ParseLineAsync).ToList();
        var results = await Task.WhenAll(tasks);

        foreach (var obj in results.Where(o => o is not null))
        {
            await _dataBaseProcessingChannel.ProcessingChannel.Writer.WriteAsync(obj!);
        }
    }

    private async Task<T?> ParseLineAsync(string[] line)
    {
        try
        {
            var obj = new T();
            foreach (var propInfo in obj.GetType().GetProperties())
            {
                if (!_fileHeaders.Contains(propInfo.Name.ToLowerInvariant()))
                {
                    continue;
                }

                var valueAsString = line[_fileHeaders.IndexOf(propInfo.Name.ToLowerInvariant())];
                var type = Nullable.GetUnderlyingType(propInfo.PropertyType) ?? propInfo.PropertyType;

                var value = type switch
                {
                    Type intType when intType == typeof(int) || intType == typeof(int?) =>
                        string.IsNullOrWhiteSpace(valueAsString) ? 0 : int.Parse(valueAsString),

                    Type stringType when stringType == typeof(string) => valueAsString,

                    Type dateType when dateType == typeof(DateTime) || dateType == typeof(DateTime?) =>
                        string.IsNullOrWhiteSpace(valueAsString)
                            ? (object)default(DateTime)
                            : DateTime.Parse(valueAsString),

                    Type decimalType when decimalType == typeof(decimal) || decimalType == typeof(decimal?) =>
                        string.IsNullOrWhiteSpace(valueAsString) ? decimal.Zero : decimal.Parse(valueAsString),

                    Type doubleType when doubleType == typeof(double) || doubleType == typeof(double?) =>
                        string.IsNullOrWhiteSpace(valueAsString) ? double.NaN : double.Parse(valueAsString),

                    Type floatType when floatType == typeof(float) || floatType == typeof(float?) =>
                        string.IsNullOrWhiteSpace(valueAsString) ? float.NaN : float.Parse(valueAsString),

                    Type guidType when guidType == typeof(Guid) => Guid.Parse(valueAsString),

                    _ => null
                };

                if (value != null)
                {
                    propInfo.SetValue(obj, value, null);
                }
            }

            return obj;
        }
        catch (Exception e)
        {
            _logger.LogWarning("Error parsing object: {EMessage}", e.Message);
            return null;
        }
    }
    
    private void ValidateHeaders(ReadOnlyCollection<string> headers, IEnumerable<string> requiredHeaders)
    {
        var missingHeaders = requiredHeaders.Except(headers).ToList();
        if (missingHeaders.Any())
        {
            throw new InvalidOperationException($"Missing required headers: {string.Join(", ", missingHeaders)}");
        }
    }
    
    private void ValidateRow(string[] rowValues, int rowIndex)
    {
        if (rowValues.Length != _fileHeaders.Count)
        {
            throw new InvalidOperationException($"Row {rowIndex + 1} does not have the expected number of columns.");
        }
    }
    
    private void ValidateFile(string filePath)
    {
        if (!File.Exists(filePath))
        {
            throw new FileNotFoundException($"File not found: {filePath}");
        }

        if (new FileInfo(filePath).Length == 0)
        {
            throw new InvalidOperationException($"File is empty: {filePath}");
        }

        if (Path.GetExtension(filePath) != ".csv" && Path.GetExtension(filePath) != ".txt")
        {
            throw new NotSupportedException($"Unsupported file type: {filePath}");
        }
    }
}